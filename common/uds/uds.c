/**
 * @file uds.c
 * @author Eileen Yoon (eyn@purdue.edu)
 * @brief  Unified Diagnostics Services (UDS)
 * @version 0.1
 * @date 2024-12-18
 *
 * @copyright Copyright (c) 2024
 *
 */

#include "uds.h"

#include "common/bootloader/bootloader.h"

static uds_variable_t *uds_tracked_vars; // autogenerated in module-specific uds.c/uds.h
static uint32_t uds_num_vars;

bool udsInitBase(uds_variable_t *uds_tracked_vars_, uint32_t uds_num_vars_)
{
    uds_tracked_vars = uds_tracked_vars_;
    uds_num_vars = uds_num_vars_;

    /* Initializing UDS in the application code implies that the current
     * application firmware is good, so mark the current partition as verified
     * (by bit flipping a metadata field in flash once) so the bootloader doesn't
     * enter backdoor mode for 3 seconds (i.e. stall) starting from the next boot and onwards.
     */
    //BL_markFirmwareVerified();

    return true;
}

static uint32_t uds_var_read_generic(uint32_t addr, uint32_t bit_length)
{
    uint32_t value; // TODO bit reader?

    if (bit_length == 1)
        value = !!(*(uint8_t *)addr); // stored in u8 anyways
    else if (bit_length <= 8)
        value = *(uint8_t *)addr;
    else if (bit_length <= 16)
        value = *(uint16_t *)addr;
    else if (bit_length <= 32)
        value = *(uint32_t *)addr;

    return value;
}

static void uds_var_write_generic(uint32_t addr, uint32_t bit_length, uint32_t value)
{
    if (bit_length == 1)
        *(uint8_t *)addr = (uint8_t)(!!value); // stored in u8 anyways
    else if (bit_length <= 8)
        *(uint8_t *)addr = (uint8_t)(value & 0xff);
    else if (bit_length <= 16)
        *(uint16_t *)addr = (uint16_t)(value & 0xffff);
    else if (bit_length <= 32)
        *(uint32_t *)addr = (uint32_t)(value & 0xffffffff);
}

#define UDS_ERR_VAR_INVALID_ID   0xDEADBEE1
#define UDS_ERR_VAR_INVALID_PERM 0xDEADBEE2
#define UDS_ERR_VAR_INVALID_BANK 0xF0

/* @uds_var_read_value
 * Accesses & reads variable stored at var->addr
 * Returns read value or error code
 */
static uint32_t uds_var_read_value(uint8_t id)
{
    uds_variable_t *var;
    uint32_t value;

    if (id >= uds_num_vars)
        return UDS_ERR_VAR_INVALID_ID;

    var = &uds_tracked_vars[id];
    if (!((uint32_t)var->perm & UDS_VAR_READ_FLAG) || !var->addr)
        return UDS_ERR_VAR_INVALID_PERM;

    // value = (*var->read_fn)(); // read
    value = uds_var_read_generic(var->addr, var->len);

    return value;
}

static void uds_var_read(uint64_t data)
{
    uint8_t id = data & 0xff;
    uint32_t value = uds_var_read_value(id);

    uds_variable_msg_t msg = {.cmd = UDS_CMD_VAR_READ, .id = id, .value = value, .pad = 0xAAAA};
    udsFrameSend(*(uint64_t *)&msg); // dispatch status
}

/* @uds_var_write_value
 * Accesses & writes to variable stored at var->addr
 * Returns written value or error code
 */
static uint32_t uds_var_write_value(uint8_t id, uint32_t value)
{
    uds_variable_t *var;

    if (id >= uds_num_vars)
        return UDS_ERR_VAR_INVALID_ID;

    var = &uds_tracked_vars[id];
    if (!((uint32_t)var->perm & UDS_VAR_WRITE_FLAG) || !var->addr)
        return UDS_ERR_VAR_INVALID_PERM;

    //(*var->write_fn)(value); // write
    uds_var_write_generic(var->addr, var->len, value);

    return value;
}

static void uds_var_write(uint64_t data)
{
    uint8_t id = data & 0xff;
    uint32_t value = (data >> 8) & 0xffffffff;

    value = uds_var_write_value(id, value);
    uds_variable_msg_t msg = {.cmd = UDS_CMD_VAR_WRITE, .id = id, .value = value, .pad = 0xAAAA};
    udsFrameSend(*(uint64_t *)&msg); // dispatch status
}

/* @uds_var_read_pin_value
 * Reads GPIO bank/pin (for HIL)
 * Returns read value or error code
 */
static uint8_t uds_var_read_pin_value(uint8_t gpio_bank, uint8_t gpio_pin)
{
    GPIO_TypeDef * bank;
    uint8_t val = 0;
    switch(gpio_bank)
    {
        case 0:
            bank = GPIOA;
            break;
        case 1:
            bank = GPIOB;
            break;
        case 2:
            bank = GPIOC;
            break;
#ifdef GPIOD
        case 3:
            bank = GPIOD;
            break;
#endif
#ifdef GPIOE
        case 4:
            bank = GPIOE;
            break;
#endif
#ifdef GPIOF
        case 5:
            bank = GPIOF;
            break;
#endif
        default:
            bank = NULL;
    }
    if (bank == NULL)
    {
        val = UDS_ERR_VAR_INVALID_BANK;
    }
    else
    {
        val = PHAL_readGPIO(bank, gpio_pin);
    }

    return val;
}

static void uds_var_read_pin(uint64_t data)
{
    uint8_t gpio_bank = data & 0xff;
    uint8_t gpio_pin = (data >> 8) & 0xff;
    uint8_t value = uds_var_read_pin_value(gpio_bank, gpio_pin);

    uds_pin_msg_t msg = {.cmd = UDS_CMD_PIN_READ, .bank = gpio_bank, .pin = gpio_pin, .value = value, .pad = 0xAAAAAAAA};
    udsFrameSend(*(uint64_t *)&msg); // dispatch
}

static void uds_sys_test(uint64_t data)
{
    uint16_t x = data & 0xffff;
    uint16_t y = (data >> 16) & 0xffff;
    uint32_t z = x + y;
    uds_test_msg_t msg = {.cmd = UDS_CMD_SYS_TEST, .x = x, .y = y, .z = z, .pad = 0xAA};
    udsFrameSend(*(uint64_t *)&msg); // dispatch
}

__WEAK void uds_handle_sub_command_callback(uint8_t cmd, uint64_t data)
{
    return;
}

/* @uds_handle_command
 * Big master switch case to process UDS commands
 */
void uds_handle_command(uint8_t cmd, uint64_t data)
{
    switch (cmd)
    {
        /* Handle SYS commands */
        case UDS_CMD_SYS_TEST:
            uds_sys_test(data);
            break;
        case UDS_CMD_SYS_RST:
            NVIC_SystemReset();
            break;

        /* Handle VAR commands */
        case UDS_CMD_VAR_READ:
            uds_var_read(data);
            break;
        case UDS_CMD_VAR_WRITE:
            uds_var_write(data);
            break;
        case UDS_CMD_PIN_READ:
            uds_var_read_pin(data);
            break;
    }

    BL_processCommand(cmd, data);

    /* Once system calls are processed, call the callback for module-specific commands */
    uds_handle_sub_command_callback(cmd, data);
}
